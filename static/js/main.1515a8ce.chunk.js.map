{"version":3,"sources":["Showtime.js","Todolist/Todoinput.js","Todolist/Todoing.js","Todolist/Todolist.js","index.js"],"names":["Component","Todoinput","handleInput","e","keyCode","props","add","target","value","handleChange","setState","name","parseInt","bind","state","inputValue","a","b","c","this","focus","ref","inp","onChange","onKeyDown","type","onClick","console","log","Todoing","idx","del","todo","map","item","key","delItem","defaultProps","Todolist","addItem","data","splice","ReactDOM","render","document","getElementById"],"mappings":"+OAIuBA,Y,qBCAFC,E,YACjB,aAAc,IAAD,8BACT,+CAYJC,YAAc,SAACC,GAEM,KAAdA,EAAEC,SAED,EAAKC,MAAMC,IAAIH,EAAEI,OAAOC,QAjBnB,EAoBbC,aAAe,SAACN,GACZ,EAAKO,SAAL,eAGKP,EAAEI,OAAOI,KAAOC,SAA4B,KAAnBT,EAAEI,OAAOC,MAAa,EAAEL,EAAEI,OAAOC,UAtB/D,EAAKN,YAAc,EAAKA,YAAYW,KAAjB,gBAEnB,EAAKC,MAAQ,CACTC,WAAW,GACXC,EAAE,GACFC,EAAE,GACFC,EAAE,IARG,E,iFA+BTC,KAAKH,EAAEI,U,+BAID,IAAD,OACL,OACI,6BAQI,2BAAQC,IAAK,SAACC,GAAO,EAAKN,EAAIM,GAAMX,KAAK,IAAIY,SAAUJ,KAAKV,aAAcD,MAAOW,KAAKL,MAAME,EAAGQ,UAAWL,KAAKjB,YAAauB,KAAK,SARrI,IAUI,2BAAOd,KAAK,IAAIY,SAAUJ,KAAKV,aAAcD,MAAOW,KAAKL,MAAMG,EAAGO,UAAWL,KAAKjB,YAAauB,KAAK,SAVxG,IAYI,2BAAOd,KAAK,IAAIY,SAAUJ,KAAKV,aAAcD,MAAOW,KAAKL,MAAMI,EAAGM,UAAWL,KAAKjB,YAAauB,KAAK,SAZxG,IAeI,2BAAIN,KAAKL,MAAME,EAAEG,KAAKL,MAAMG,EAAEE,KAAKL,MAAMI,GAQzC,2BAAOG,IAAK,SAACC,GAAO,EAAKA,IAAIA,GAAMG,KAAK,SACxC,4BAAQC,QAAS,WAAKC,QAAQC,IAAI,EAAKN,OAAvC,qB,GA9DuBtB,aCGlB6B,E,gLACRC,EAAI3B,GACTwB,QAAQC,IAAIzB,GACZgB,KAAKd,MAAM0B,IAAID,K,+BAET,IAAD,OAMAE,EAAQb,KAAKd,MAAb2B,KACL,OACI,4BAWQA,EAAKC,KAAI,SAACC,EAAKJ,GAAN,OAAY,wBAAIK,IAAKL,GAAMI,EAAf,MAAuB,4BAAQR,QAAS,EAAKU,QAAQvB,KAAK,EAAKiB,IAAxC,yB,GAxB3B9B,aAqCrC6B,EAAQQ,aAAe,CAEnBL,KAAO,CAAC,EAAE,EAAE,EAAE,I,ICpCGM,E,YAEjB,aAAc,IAAD,8BACT,+CAMJC,QAAU,SAACC,GAKP,EAAK9B,SAAS,CACVsB,KAAK,GAAD,mBAAK,EAAKlB,MAAMkB,MAAhB,CAAqBQ,OAbpB,EAiBbJ,QAAU,SAACN,EAAI3B,GAGX,IAAI6B,EAAI,YAAO,EAAKlB,MAAMkB,MAC1BA,EAAKS,OAAOX,EAAI,GAUhB,EAAKpB,UAAS,SAACI,EAAMT,GAEjB,OADAsB,QAAQC,IAAId,EAAMkB,MACZ,CACFA,KAAKA,OAhCb,EAAKlB,MAAQ,CACTkB,KAAK,CAAC,EAAE,EAAE,IAHL,E,sEAiET,OACI,6BAEI,kBAAC,EAAD,CAAW1B,IAAKa,KAAKoB,UAErB,kBAAC,EAAD,CAASR,IAAKZ,KAAKiB,QAASJ,KAAQb,KAAKL,MAAMkB,Y,GAxEzBhC,aCiCfA,YAsHvB0C,IAASC,OAAO,kBAAC,EAAD,MAAYC,SAASC,eAAe,W","file":"static/js/main.1515a8ce.chunk.js","sourcesContent":["import React,{Fragment,Component} from 'react'; //React库\n\n\n//类定义组件\nclass ShowTime extends Component{//声明时直接导出 export default class ShowTime extends Component\n    constructor(){\n        super();//将父类的this传递给子类\n        this.state = {\n            time: new Date().toLocaleString(),\n            a:100,\n            b:200\n        }\n        setInterval(()=>{\n            this.setState({\n                time: new Date().toLocaleString()\n            })//使页面进行改变\n        },1000)\n    }\n\n\n    shouldComponentUpdate(){\n        if(this.state.a>10){\n            return true;\n        }\n        return false;\n    }\n    \n\n    componentDidUpdate(preProps,preState,data){\n        console.log(\"didupdate\");\n        // console.log(data);\n        console.log(preProps);\n        console.log(preState);\n        \n    }\n    getSnapshotBeforeUpdate(){\n        console.log(\"getSnapshot\");\n        return {name:this.state.name}\n    }\n    componentDidMount(){\n        console.log(\"didmount\");\n    }\n\n\n\n    render(){\n        console.log('render');\n        //一\n        var {name,age} = this.props;\n        return(\n            <Fragment>\n                {/* 条件渲染  某种情况下再显示*/}\n\n                {/* 三目运算符 */}\n                {name.length>5?<div>姓名:{name}</div>:''}\n                {/* 短路操作 */}\n                {name.length>5&&<div>姓名:{name}</div>}\n\n                <div>{this.state.time}</div>\n                {/* <div>姓名:{name}</div> */}\n                {/* <div>年龄:{age}</div> */}\n                {/**循环渲染 */}\n                <div>\n                    {\n                        // age.map((item,index)=>{\n                        //     return <p key={index}>{item}</p>\n                        // })\n                        // age.map((item)=>{\n                        //     return <p key={item}>{item}</p>\n                        // })\n\n                        // 显示偶数\n                        age.map((item,index)=>{\n                            if(index%2 === 0){\n                                return <p key={index}>{item}</p>\n                            }                            \n                        })\n\n                    }\n                </div>\n            </Fragment>\n        )\n        //二\n        // return(\n        //     <Fragment>\n        //         <div>姓名:{this.props.name}</div>\n        //         <div>年龄:{this.props.age}</div>\n        //     </Fragment>\n        // )\n    }\n}\n\n//import导入 \n//export导出\n\n//默认导出：只能导出一次，在被引入组件时，可以重命名 import Showtime from './Showtime'; 前面的showtime\nexport default ShowTime;\n\n//命名导出:可以导出多个，被引入时与导出的名一致\n// export{ShowTime};\n// export const num = 100;\n// export const num1 = 200;\n","import React, { Component } from 'react'\n//受控组件：value值被react控制的表单元素\n// 可以实时获取表单元素的值(实现表单验证)/写法相对麻烦\n\nexport default class Todoinput extends Component {\n    constructor(){//绑定事件处理函数的this 把当前this绑到handleInput上去\n        super();\n        this.handleInput = this.handleInput.bind(this);\n        // 声明一个状态，把他的值被状态控制\n        this.state = {\n            inputValue:'',\n            a:'',\n            b:'',\n            c:''\n        }\n        // this.a.focus(); render还没有渲染 还没有标签 所以拿不到值\n    }\n\n    handleInput = (e)=>{//e事件对象 可改成箭头函数 handleInput (e){\n        //绑定this，事件处理函数写成箭头函数，或者用bind\n        if(e.keyCode === 13){//键值 回车13\n            //console.log(e.target.value);//代表当前的结点\n            this.props.add(e.target.value);//属性是一个函数\n        }      \n    }\n    handleChange = (e)=>{\n        this.setState({\n            // inputValue:e.target.value,//当前的值\n            // [e.target.name]:e.target.value //[变量] 字符串类型\n            [e.target.name]: parseInt(e.target.value === ''?0:e.target.value)    \n        }) \n    }\n\n    // 标签加载完之后 自动调用声明周期 在render之后执行\n    componentDidMount(){\n        // console.log(this);\n        this.a.focus();\n        // this.refs.a.focus();\n    }\n\n    render() {\n        return (\n            <div>\n                {/* value=\"abc\" input框的默认值 写上value值后被react控制 无法再更改 受控组件 */}\n                {/* this.state.inputValue三个框用的同一个状态值赋  this.state.a this.state.b this.state.c 每个框都有一个name属性*/}\n                {/* <input  onChange={this.handleChange} value={this.state.inputValue} onKeyDown={this.handleInput} type=\"text\"/> */}\n\n                {/* ref获取结点 拿到结点的引用 调他的方法 */}\n                {/* ref={(inp)=>{this.a = inp}}  this.a.focus();*/}\n                {/* ref='a' this.refs.a.focus(); */}\n                <input  ref={(inp)=>{this.a = inp}} name=\"a\" onChange={this.handleChange} value={this.state.a} onKeyDown={this.handleInput} type=\"text\"/>             \n                +\n                <input name=\"b\" onChange={this.handleChange} value={this.state.b} onKeyDown={this.handleInput} type=\"text\"/>\n                +\n                <input name=\"c\" onChange={this.handleChange} value={this.state.c} onKeyDown={this.handleInput} type=\"text\"/>\n                =\n                {/* {parseInt(this.state.a===''?0:this.state.a)+parseInt(this.state.b)+parseInt(this.state.c)} */}\n                <p>{this.state.a+this.state.b+this.state.c}</p>\n                {/* button 拿到 input标签的值 用原生方法 this.state.inputValue */}\n                {/* <button onClick={()=>{console.log()}}>提交</button> */}\n\n                {/* 非受控组件：一次性获取或处理表单元素的值 */}\n                {/* 获取input结点的方法 拿到他的引用直接拿他的值 改变值时要绑onchange事件 setState*/}\n                {/* inp === inp this.inp===this,inp */}\n                {/* ref获取结点 */}\n                <input ref={(inp)=>{this.inp=inp}} type=\"text\"/>\n                <button onClick={()=>{console.log(this.inp)}}>提交</button> \n            </div>\n        )\n    }\n}\n\n//受控组件\n// 1、给input标签添加value属性，赋值为state的值\n// 2、给input标签绑定onChange事件，在事件处理函数中setState\n// 3、一个事件处理函数控制多个表单元素时，给input标签加上name属性,事件处理函数中写 setState({[e.target.name]:e.target.value})\n\n\n// 一进来刷新第一个框就获得焦点","//快捷键rcc\n//文件名和组件名保持一致\nimport React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n// PropTypes 提供一系列验证器，可用于确保组件接收到的数据类型是有效的。\nimport Todoinput from './Todoinput';\n\nexport default class Todoing extends Component {\n    delItem (idx,e){//隐式传入事件处理函数e\n        console.log(e);\n        this.props.del(idx);\n    }\n    render() {\n        // return (\n        //     <ul>\n        //         <li>代办事项1</li>\n        //     </ul>\n        // )\n        var {todo} = this.props;\n        return(\n            <ul>\n                {\n                    // todo.map((item)=>{\n                    //     return <li>{item}</li>\n                    // })\n                    // todo.map((item)=>return <li>{item}</li>)\n                    //外层的箭头函数是事件处理函数\n                    //(e)=>this.props.del(idx,e)}继续传参 e (e)=>this.props.事件处理函数\n                    //不需要传参时为this.props.del\n                    //需要传参时 外面加事件处理函数 箭头函数匿名函数\n                    // todo.map((item,idx)=><li key={idx}>{item}---<button onClick={(e)=>this.props.del(idx,e)}>删除</button></li>)\n                    todo.map((item,idx)=><li key={idx}>{item}---<button onClick={this.delItem.bind(this,idx)}>删除</button></li>)\n                }\n            </ul>\n        )\n    }\n}\n\n//类型检查\nTodoing.propTypes = {//用到PropTypes 才需要引入包\n    //属性的类型检查\n    todo: PropTypes.array,//应该是一个数组\n    del: PropTypes.func//应该是一个函数\n}\nTodoing.defaultProps = {\n    //没有传参的话 默认值会生效\n    todo : [1,2,3,4]\n}\n","// 组件声明的两种方式\n// 状态和属性props父组件传进来的\n\n\n//Todolist引到index.js中去 \n//Todoinput.js和Todoing.js引导Todolist.js中去\nimport React, { Component } from 'react'\nimport Todoinput from './Todoinput'\nimport Todoing from './Todoing'\n\nexport default class Todolist extends Component {\n    //状态在构造器中声明\n    constructor(){\n        super();\n        this.state = {\n            todo:[1,2,3]\n        }\n    }\n    //子组件往父组件传 传一个函数\n    addItem = (data)=>{\n        // console.log(data);\n        // this.state.todo.push(data);\n        // console.log(this.state.todo);\n\n        this.setState({//改变状态 setstate\n            todo:[...this.state.todo,data]//用新数组去覆盖原数组\n        })\n    }\n\n    delItem = (idx,e)=>{\n        // 1、不能直接改变或处理state,通过setState改变\n        // console.log(idx);\n        let todo = [...this.state.todo];\n        todo.splice(idx,1)\n        //2、setState是异步执行\n        // this.setState({\n        //     todo:todo//解构赋值\n        //     todo:this.state.num+100 //this.state.num 拿到的不是前一个state\n        // },()=>{//callback回调函数 执行完 执行回调函数\n        //     console.log(this.state.todo);//最新的值[2,3]\n        // })\n        // console.log(this.state.todo);//原来的值[1,2,3]\n\n        this.setState((state,props)=>{//第一个参数可以写一个函数 拿到的是前一个state\n            console.log(state.todo);\n            return{\n                todo:todo\n            }\n        })\n        // 在setState里获取state可能会出错，不是你想要的值\n        // 可以像上面那样，把第一个参数写成函数，解决该问题\n    }\n\n    // delItem = (idx)=>{\n    //     //深拷贝\\浅拷贝\n    //     //引用是浅拷贝 不能生成新数组\n    //     var obj = {a:100,b:[1,2,3]};\n    //     var obj1 = {c:300};\n    //     // var o = {...obj};\n    //     var o = Object.assign(obj,obj1);// true 把原对象方法整合到目标对象上去\n    //     var o = Object.assign({},obj,obj1);// false\n    //     // var o= JSON.parse(JSON.stringify(obj));// 深拷贝 将对象转换成普通字符串再转换成对象 和原对象不一样\n    //     // o.a = 200;\n    //     // o.b[0] = 200;\n    //     console.log(o===obj);\n\n    //     // 遍历对象 for in可以不大好\n    //     console.log(Object.keys(obj));//返回对象组成的字符串数组\n    //     Object.keys(obj).forEach((item)=>{\n    //         console.log(item);\n    //         console.log(obj[item]);\n    //     })\n\n    // }\n\n    // 属性、状态一变 函数自动渲染\n    render() {\n        return (\n            <div>\n                {/* add是属性 */}\n                <Todoinput add={this.addItem}/>\n                {/* 父组件往子组件传 */}\n                <Todoing del={this.delItem} todo = {this.state.todo}/>\n                {/* todo名字可以随便起 */}\n                {/* <Todoing todo = {this.state.todo}/> */}\n            </div>\n        )\n    }\n}","import React,{Fragment,Component} from 'react'; //React库\nimport ReactDOM from 'react-dom';\n// import App from './App';\nimport './index.css';\nimport Showtime from './Showtime';//默认导出 \n//import {Showtime} from '/Showtime';//命名导出\nimport Todolist from './Todolist/Todolist';\n\n// JSX语法\n// var ele = <div>hello</div>;//Rect元素不可变\n// ReactDOM.render(\n//     ele,\n//     document.querySelector('#root')\n// );\n\n//显示当前的系统时间\n//不变\n// var ele = <div>{new Date().toLocaleString()}</div>;//Rect元素不可变\n// ReactDOM.render(\n//     ele,\n//     document.querySelector('#root')\n// );\n\n//改变 再渲染一次 变量再重新赋值 套入函数中 每隔一秒钟执行一次\n// function showTime(){\n//     // var ele = <div>{new Date().toLocaleString()}</div>;//Rect元素不可变\n//     var ele = <div>\n//                 <p>当前时间是:</p>\n//                 <div>{new Date().toLocaleString()}</div>\n//             </div>;//Rect元素不可变\n//     ReactDOM.render(\n//         ele,\n//         document.querySelector('#root')\n//     );\n// }\n// showTime();\n// setInterval(showTime,1000);\n\n\n\n\n// 在js中声明一个类\n// 能用函数就不要用类\nclass ShowTime extends Component{\n    constructor(){\n        super();//将父类的this传递给子类\n        this.state = {\n            time: new Date().toLocaleString(),\n            a:100,\n            b:200\n        }\n        setInterval(()=>{\n            this.setState({\n                time: new Date().toLocaleString()\n            })//使页面进行改变\n        },1000)\n    }\n\n\n    shouldComponentUpdate(){\n        if(this.state.a>10){\n            return true;\n        }\n        return false;\n    }\n    \n\n    componentDidUpdate(preProps,preState,data){\n        console.log(\"didupdate\");\n        // console.log(data);\n        console.log(preProps);\n        console.log(preState);\n        \n    }\n    getSnapshotBeforeUpdate(){\n        console.log(\"getSnapshot\");\n        return {name:this.state.name}\n    }\n    componentDidMount(){\n        console.log(\"didmount\");\n    }\n\n\n\n    render(){\n        console.log('render');\n        //一\n        var {name,age} = this.props;\n        return(\n            <Fragment>\n                {/* 条件渲染  某种情况下再显示*/}\n\n                {/* 三目运算符 */}\n                {name.length>5?<div>姓名:{name}</div>:''}\n                {/* 短路操作 */}\n                {name.length>5&&<div>姓名:{name}</div>}\n\n                <div>{this.state.time}</div>\n                {/* <div>姓名:{name}</div> */}\n                {/* <div>年龄:{age}</div> */}\n                {/**循环渲染 */}\n                <div>\n                    {\n                        // age.map((item,index)=>{\n                        //     return <p key={index}>{item}</p>\n                        // })\n                        // age.map((item)=>{\n                        //     return <p key={item}>{item}</p>\n                        // })\n\n                        // 显示偶数\n                        age.map((item,index)=>{\n                            if(index%2 === 0){\n                                return <p key={index}>{item}</p>\n                            }                            \n                        })\n\n                    }\n                </div>\n            </Fragment>\n        )\n        //二\n        // return(\n        //     <Fragment>\n        //         <div>姓名:{this.props.name}</div>\n        //         <div>年龄:{this.props.age}</div>\n        //     </Fragment>\n        // )\n    }\n}\n\n\n\n\n\n//组件 首字母大写\n//用函数声明组建\n// function ShowTime(props){\n//     console.log(props);\n//     //return <div>{props.name}{new Date().toLocaleString()}</div>;//用到变量的地方都要用大括号\n    \n//     // return (<div></div>\n//     //         <div>\n//     //         {props.name}{new Date().toLocaleString()}\n//     //         </div>\n//     //     );//错误 外层只能有一个div对象 可以用一个div把他们包裹起来\n\n//     return(<Fragment>\n//                 <div>{props.name}</div>\n//                 <div>\n//                     {new Date().toLocaleString()}\n//                 </div>\n//             </Fragment>            \n//         )//返回值一定要包裹在一个闭合的标签里面\n// }\n\n//组件交互\n// 父组件----->子组件：调用子组件时在标签上添加属性，子组件通过props拿到传递的数据\n// 子组件----->父组件：\n\n//引入Todolist\nReactDOM.render(<Todolist/>,document.getElementById('root'))\n\n\n// var num = [1,2,3,4,5];\n// ReactDOM.render(\n//     // <ShowTime age=\"20\" name=\"zhangsan\"/>,\n//     <ShowTime age={num} name=\"zhangsan\"/>,\n//     document.getElementById('root')\n// )\n\n\n\n\n// var str = 'react';\n// var ele = <h1 class=\"tit\">hello {str}</h1>;//不是一个标签\n// var ele = <h1 class=\"tit\">hello <p>react</p> </h1>;//不是一个标签\n\n// var obj = {\n//     type: 'div',\n//     props: {\n//         id: 'box',\n//         class: 'box',\n//         children: [\n//             'hello',\n//             'react',\n//             {\n//                 type: 'h1',\n//                 props: {\n//                     id: 'tit',\n//                     class: 'tit',\n//                     children: [//children是子元素\n//                         'title',\n//                         'react'\n//                     ]\n//                 }\n//             }\n//         ]\n//     }\n// }\n// // var ele = React.createElement(\n// //     'h1',\n// //     {id:'tit',class:'title'},\n// //     'hello',\n// //     React.createElement(\n// //         'p',\n// //         {id:'t',class:'tit'},\n// //         'react'\n// //     )\n// // );\n// // console.log(ele);\n// // ReactDOM.render(ele, document.getElementById('root'));\n\n// // If you want your app to work offline and load faster, you can change\n// // unregister() to register() below. Note this comes with some pitfalls.\n// // Learn more about service workers: https://bit.ly/CRA-PWA\n\n\n\n\n// // render函数的实现方法\n// function render(obj,container){//渲染\n//     //解构赋值\n//     var {type,props} = obj;\n//     //文档碎片 内存中开辟一块空间进行操作 一次渲染到DOM\n//     var fragment = document.createDocumentFragment();//类似于结点\n\n//     var ele = document.createElement(type);//obj.type\n//     for(var item in obj.props){\n//         if(item === 'class'){\n//             ele.className = props[item];//obj.props\n//         }else if(item === 'children'){\n//             for(var i = 0;i<=props.children.length;i++){//props[item].length\n//                 // ele.innerHTML += props.children[i];\n//                 if(typeof props.children[i]==='object'){//是一个对象\n//                     render(props.children[i],ele);\n//                 }else{\n//                     var txt = document.createTextNode(props.children[i]);\n//                     ele.appendChild(txt);\n//                 }               \n//             }\n\n//         }\n//         else{\n//             // ele.item = obj.props.item; //.属性\n//             ele[item] = props[item];//item是一个变量 [变量]\n//         }\n\n//     }\n//     fragment.appendChild(ele);\n//     container.appendChild(fragment);//一次添加\n//     // container.appendChild(ele);\n\n// }\n\n// render(obj,document.getElementById('root'));\n\n//页面渲染过程\n//请求HTML页面，浏览器HTML解析器解析html文件，生成DOM树\n//link引入css文件、css解析器解析css，生成css对象模型，CSSOM和DOM tree 结合生成一个render tree 绘制出页面\n\n//页面回流（重排reflow）：DOM结构变化、内容变化、大小、位置的变化\n//页面重绘（repaint）：颜色的变化（背景色、字体颜色、边框颜色） 代价小\n\n//(一)先用变量进行dom处理，最后一次渲染\n// console.time('time');\n// for (var i = 0;i<1000;i++){\n//     document.getElementById('root').innerHTML += '<p>'+i+'</p>';\n// }\n// console.timeEnd('time');\n\n//修改后\n// console.time('time');\n// var div = document.getElementById('root');\n// var str = ''\n// for (var i = 0;i<1000;i++){\n//     str += '<p>'+i+'</p>';\n// }\n// div.innerHTML = str;\n// console.timeEnd('time');\n\n//(二)对于样式的处理\n// var div = document.getElementById('root');\n// div.style.width = '100px';//回流\n// div.style.height = '100px';//回流\n// div.style.background = 'red';//重绘\n\n//修改后\n//声明一个css的类\n// .active{\n//     width:100px;\n//     height:100px;\n//     background:red;\n// }\n//div.className ='active';//只引起一次回流\n\n//(三)offsetLeft、offsetWidth等都会引起回流,要慎用 \n// console.log(div.offsetLeft);\n// setInterval(()=>{\n//     div.style.width = div.offsetWidth+1+'px';\n// },100)\n\n//修改后\n// console.log(div.offsetLeft);\n// var wid = div.offsetWidth;//变量不会引起回流\n// setInterval(()=>{\n//     wid += 1;\n//     div.style.width = wid+1+'px';\n// },100)\n\n"],"sourceRoot":""}